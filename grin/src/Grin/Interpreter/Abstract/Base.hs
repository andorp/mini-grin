{-# LANGUAGE TemplateHaskell, GeneralizedNewtypeDeriving, TypeFamilies, InstanceSigs, LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses, RankNTypes, ScopedTypeVariables, RecordWildCards #-}
module Grin.Interpreter.Abstract.Base where

import Control.Applicative (Alternative(..))
import Control.Monad.Fail (MonadFail(..))
import Control.Monad.IO.Class (MonadIO(..))
import Control.Monad.Logic hiding (fail)
import Control.Monad.Reader (MonadReader(..))
import Control.Monad.State (MonadState(..))
import Control.Monad.Trans.RWS.Strict hiding (ask, local, get)
import Grin.Exp(Exp(..), Program)
import Grin.Value (Name, Tag)
import Grin.Interpreter.Base (programToDefs)
import Grin.Pretty hiding (SChar)
import Lens.Micro.Platform
import Prelude hiding (fail)

import Grin.Interpreter.Store (Store)
import qualified Grin.Interpreter.Store as Store
import Grin.Interpreter.Env (Env(..))
import qualified Grin.Interpreter.Env as Env
import qualified Data.Map.Strict as Map
import qualified Data.Set as Set; import Data.Set (Set)


data ST
  = ST_Int64
  | ST_Word64
  | ST_Float
  | ST_Bool
  | ST_Char
  | ST_Loc Loc
  deriving (Eq, Ord, Show)

data Node = Node Tag [ST]
  deriving (Eq, Ord, Show)

data T
  = ST ST
  | NT Node
  | UT
  deriving (Eq, Ord, Show)

-- The abstract location is generated by the variable
-- which was associated with the store. (l <- store _)
data Loc = Loc Name
  deriving (Eq, Ord, Show)

data AbsEnv
  = AbsEnv
  { _absOps :: Map.Map Name (T, [T])
  , _absEnv :: Env T            -- Names in scope
  , _absFun :: Map.Map Name Exp -- How to record the type of function parameters? As now the interpeter calls the
                                -- function during the evaluation, and the current parameters are recorded in the
                                -- environment? Maybe a state will be needed instead of the Reader monad?
                                -- Or the lookupFun and the SApp needs a different implementation? OR the SApp
                                -- should be implemented as the ecase?
  }

makeLenses ''AbsEnv

newtype FunctionT = FunctionT (Set T, [Set T])
  deriving (Eq)

data TypeEnv = TypeEnv
  { _location :: AbsStore
  , _variable :: Env (Set T)
  , _function :: Map.Map Name FunctionT
  } deriving (Eq)

type AbsStore = Store Loc (Set Node)

data AbsState
  = AbsState
  { _absStr :: AbsStore
  } deriving (Show, Eq)

makeLenses ''AbsState


-- Exercise: Read the https://plum-umd.github.io/abstracting-definitional-interpreters/#%28part._s~3acache%29
-- to get the high level ides of the definition below.
newtype AbstractT m a = AbstractT
  { abstractT ::
      RWST -- Reader Writer State of the current execution stack
        AbsEnv    -- Abstract environment for the current execution
        ()        -- No logging
        AbsState  -- Abstract Store for the current execution stack
        (LogicT               -- LogicT for handle non-determinism from branching in case expressions
          (RWST               -- Reader Writer State for the whole program, where the
            (TypeEnv, Cache)  --  Reader is an input parameter for the fix-point finding in one iteration
            ()                --  No Logging
            (TypeEnv, Cache)  --  State is the output for the fix-point finding in one iteration
            m))
        a
  } deriving
    ( Functor
    , Applicative
    , Monad
    , MonadIO
    , MonadState AbsState
    , MonadReader AbsEnv
    , Alternative
    , MonadPlus
    )

instance MonadFail (AbstractT m) where
  fail _ = mzero

runAbstractT
  :: (Monad m, MonadFail m, MonadIO m)
  => Program -> [(Name, (T, [T]))]
  -> AbstractT m a -> m ([(a, AbsState, ())], (TypeEnv,Cache), ())
runAbstractT prog ops m =
  runRWST
    (observeAllT
      (runRWST
        (abstractT m)
        (AbsEnv (Map.fromList ops) Env.empty (programToDefs prog))
        (AbsState Store.empty)))
    mempty
    mempty

forMonadPlus :: (MonadPlus m) => [a] -> (a -> m b) -> m b
forMonadPlus xs k = msum (map k xs)

data Cache = Cache (Map.Map Config (Set.Set (T, AbsStore)))
  deriving (Eq, Show)

data Config = Config
  { cfgEnv    :: Env T
  , cfgStore  :: AbsStore
  , cfgExp    :: CExp
  } deriving (Eq, Show, Ord)

data CExp
  = CApp     Name [Name]
  deriving (Eq, Show, Ord)

-- * Cache operations

cacheSize :: Cache -> [Int]
cacheSize (Cache m) = Map.elems $ fmap Set.size m

inCache :: Config -> Cache -> Bool
inCache c (Cache m) = Map.member c m

getCache :: Config -> Cache -> [(T, AbsStore)]
getCache c (Cache m) = maybe [] Set.toList $ Map.lookup c m

insertCache :: Config -> [(T, AbsStore)] -> Cache -> Cache
insertCache c vos (Cache m) = Cache (Map.unionWith (<>) m (Map.singleton c (Set.fromList vos)))

-- * Monoid instances

instance Semigroup TypeEnv where
  TypeEnv l1 v1 f1 <> TypeEnv l2 v2 f2 = TypeEnv (l1 <> l2) (v1 <> v2) (Map.unionWith (<>) f1 f2)

instance Monoid TypeEnv where
  mempty = TypeEnv mempty mempty mempty

instance Semigroup Cache where
  (Cache ma) <> (Cache mb) = Cache (Map.unionWith (Set.union) ma mb)

instance Monoid Cache where
  mempty = Cache mempty

instance Semigroup FunctionT where
  (FunctionT (r1,ps1)) <> (FunctionT (r2,ps2)) = FunctionT ((r1 <> r2),(zipWith (<>) ps1 ps2)) -- TODO: Check

instance Monoid FunctionT where
  mempty = FunctionT mempty
