{-# LANGUAGE LambdaCase, TemplateHaskell, RecordWildCards #-}
module Grin.TypeEnv.Intermediate where

import Data.Set (Set)
import Grin.Interpreter.Env
import Grin.Interpreter.Store
import Grin.Value as Grin hiding (Node)

import qualified Data.Map as Map
import qualified Data.Set as Set


-- The abstract location is generated by the variable
-- which was associated with the store. (l <- store _)
newtype Loc = Loc Name
  deriving (Eq, Ord, Show)

-- | Simple type for simple values
data ST
  = ST_Int64
  | ST_Word64
  | ST_Float
  | ST_Bool
  | ST_Char
  | ST_Loc !Loc
  deriving (Eq, Ord, Show)

-- | Node type consist of a Tag and a indexed map with simple type
data Node = Node !Tag ![ST]
  deriving (Eq, Ord, Show)

-- | The final type could be a Simple-type a Node type or a Unit type
data T
  = ST !ST   -- Simple type
  | NT !Node -- Node type
  | UT      -- Unit type, which is associated with Update and effectful primops
  deriving (Eq, Ord, Show)

typeOfSimpleValue :: Grin.SimpleValue -> T
typeOfSimpleValue = \case
  Grin.SInt64  _ -> ST ST_Int64
  Grin.SWord64 _ -> ST ST_Word64
  Grin.SFloat  _ -> ST ST_Float
  Grin.SBool   _ -> ST ST_Bool
  Grin.SChar   _ -> ST ST_Char

-- | The function type collects the set of possible types.
newtype FunctionT = FunctionT (Set T, [Set T])
  deriving (Eq)

-- | The type-env that is computed during the abstract interpretation.
data TypeEnv = TypeEnv
  { _heap     :: Store Loc (Set Node)    -- The abstract heap associated abstract locations with set of Node values
  , _variable :: Env (Set T)             -- The environment which collects all the possible types for the variable names
  , _function :: Map.Map Name FunctionT  -- The Map which associates function names with function types
  } deriving (Eq)
