-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package grin
@version 0.1.0.0

module Data.Functor.FoldableM

-- | apoM is the monadic counterpart of the apomorphism. Exercise: Read the
--   definition of the ana and apo
--   <a>http://hackage.haskell.org/package/recursion-schemes-5.1.3/docs/src/Data.Functor.Foldable.html#ana</a>
--   <a>http://hackage.haskell.org/package/recursion-schemes-5.1.3/docs/src/Data.Functor.Foldable.html#apo</a>
--   
--   In general apo is an extended anamorphism. Anamoprhism builds up an
--   expression tree, using a seed and a function that creates a new layer
--   of the tree. Anamorphism builds the tree from top to bottom.
--   
--   The apomorphism, has the ability to generate a subtree in one go and
--   stop the recursion there.
--   
--   apoM is the Monadic variant, which can have some side effect meanwhile
--   the generation of the next layer happens.
apoM :: (Monad m, Traversable (Base t), Corecursive t) => (a -> m (Base t (Either t a))) -> a -> m t

module Grin.Pretty
newtype PP a
PP :: a -> PP a
newtype WPP a
WPP :: a -> WPP a
showWidth :: Int -> Doc -> String
showWide :: Doc -> String
prettyKeyValue :: (Pretty k, Pretty v) => [(k, v)] -> Doc
prettyFunction :: (Pretty a, Pretty name) => (name, (a, [a])) -> Doc
keywordR :: String -> Doc
keyword :: String -> Doc

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | <tt>(hPutDoc handle doc)</tt> pretty prints document <tt>doc</tt> to
--   the file handle <tt>handle</tt> with a page width of 80 characters and
--   a ribbon width of 32 characters.
--   
--   <pre>
--   main = do{ handle &lt;- openFile "MyFile" WriteMode
--            ; hPutDoc handle (vcat (map text
--                              ["vertical","text"]))
--            ; hClose handle
--            }
--   </pre>
--   
--   Any ANSI colorisation in <tt>doc</tt> will be output.
hPutDoc :: Handle -> Doc -> IO ()

-- | The action <tt>(putDoc doc)</tt> pretty prints document <tt>doc</tt>
--   to the standard output, with a page width of 80 characters and a
--   ribbon width of 32 characters.
--   
--   <pre>
--   main :: IO ()
--   main = do{ putDoc (text "hello" &lt;+&gt; text "world") }
--   </pre>
--   
--   Which would output
--   
--   <pre>
--   hello world
--   </pre>
--   
--   Any ANSI colorisation in <tt>doc</tt> will be output.
putDoc :: Doc -> IO ()

-- | <tt>(displayIO handle simpleDoc)</tt> writes <tt>simpleDoc</tt> to the
--   file handle <tt>handle</tt>. This function is used for example by
--   <a>hPutDoc</a>:
--   
--   <pre>
--   hPutDoc handle doc  = displayIO handle (renderPretty 0.4 80 doc)
--   </pre>
--   
--   Any ANSI colorisation in <tt>simpleDoc</tt> will be output.
displayIO :: Handle -> SimpleDoc -> IO ()

-- | <tt>(displayS simpleDoc)</tt> takes the output <tt>simpleDoc</tt> from
--   a rendering function and transforms it to a <a>ShowS</a> type (for use
--   in the <a>Show</a> class).
--   
--   <pre>
--   showWidth :: Int -&gt; Doc -&gt; String
--   showWidth w x   = displayS (renderPretty 0.4 w x) ""
--   </pre>
--   
--   ANSI color information will be discarded by this function unless you
--   are running on a Unix-like operating system. This is due to a
--   technical limitation in Windows ANSI support.
displayS :: SimpleDoc -> ShowS

-- | <tt>(renderCompact x)</tt> renders document <tt>x</tt> without adding
--   any indentation. Since no 'pretty' printing is involved, this renderer
--   is very fast. The resulting output contains fewer characters than a
--   pretty printed version and can be used for output that is read by
--   other programs.
--   
--   This rendering function does not add any colorisation information.
renderCompact :: Doc -> SimpleDoc

-- | A slightly smarter rendering algorithm with more lookahead. It
--   provides provide earlier breaking on deeply nested structures For
--   example, consider this python-ish pseudocode:
--   <tt>fun(fun(fun(fun(fun([abcdefg, abcdefg])))))</tt> If we put a
--   softbreak (+ nesting 2) after each open parenthesis, and align the
--   elements of the list to match the opening brackets, this will render
--   with <tt>renderPretty</tt> and a page width of 20 as: <tt>
--   fun(fun(fun(fun(fun([ | abcdef, | abcdef, ] ))))) | </tt> Where the
--   20c. boundary has been marked with |. Because <tt>renderPretty</tt>
--   only uses one-line lookahead, it sees that the first line fits, and is
--   stuck putting the second and third lines after the 20-c mark. In
--   contrast, <tt>renderSmart</tt> will continue to check that the
--   potential document up to the end of the indentation level. Thus, it
--   will format the document as:
--   
--   <pre>
--   fun(                |
--     fun(              |
--       fun(            |
--         fun(          |
--           fun([       |
--                 abcdef,
--                 abcdef,
--               ]       |
--     )))))             |
--   </pre>
--   
--   Which fits within the 20c. boundary.
renderSmart :: Float -> Int -> Doc -> SimpleDoc

-- | This is the default pretty printer which is used by <a>show</a>,
--   <a>putDoc</a> and <a>hPutDoc</a>. <tt>(renderPretty ribbonfrac width
--   x)</tt> renders document <tt>x</tt> with a page width of
--   <tt>width</tt> and a ribbon width of <tt>(ribbonfrac * width)</tt>
--   characters. The ribbon width is the maximal amount of non-indentation
--   characters on a line. The parameter <tt>ribbonfrac</tt> should be
--   between <tt>0.0</tt> and <tt>1.0</tt>. If it is lower or higher, the
--   ribbon width will be 0 or <tt>width</tt> respectively.
renderPretty :: Float -> Int -> Doc -> SimpleDoc

-- | Removes all colorisation, emboldening and underlining from a document
plain :: Doc -> Doc

-- | Displays a document with no underlining
deunderline :: Doc -> Doc

-- | Displays a document with underlining
underline :: Doc -> Doc

-- | Displays a document in the normal font weight
debold :: Doc -> Doc

-- | Displays a document in a heavier font weight
bold :: Doc -> Doc

-- | Displays a document with the dull white backcolor
ondullwhite :: Doc -> Doc

-- | Displays a document with the white backcolor
onwhite :: Doc -> Doc

-- | Displays a document with the dull cyan backcolor
ondullcyan :: Doc -> Doc

-- | Displays a document with the cyan backcolor
oncyan :: Doc -> Doc

-- | Displays a document with the dull magenta backcolor
ondullmagenta :: Doc -> Doc

-- | Displays a document with the magenta backcolor
onmagenta :: Doc -> Doc

-- | Displays a document with the dull blue backcolor
ondullblue :: Doc -> Doc

-- | Displays a document with the blue backcolor
onblue :: Doc -> Doc

-- | Displays a document with the dull yellow backcolor
ondullyellow :: Doc -> Doc

-- | Displays a document with the yellow backcolor
onyellow :: Doc -> Doc

-- | Displays a document with the dull green backcolor
ondullgreen :: Doc -> Doc

-- | Displays a document with the green backcolor
ongreen :: Doc -> Doc

-- | Displays a document with the dull red backcolor
ondullred :: Doc -> Doc

-- | Displays a document with the red backcolor
onred :: Doc -> Doc

-- | Displays a document with the dull black backcolor
ondullblack :: Doc -> Doc

-- | Displays a document with the black backcolor
onblack :: Doc -> Doc

-- | Displays a document with the dull white forecolor
dullwhite :: Doc -> Doc

-- | Displays a document with the white forecolor
white :: Doc -> Doc

-- | Displays a document with the dull cyan forecolor
dullcyan :: Doc -> Doc

-- | Displays a document with the cyan forecolor
cyan :: Doc -> Doc

-- | Displays a document with the dull magenta forecolor
dullmagenta :: Doc -> Doc

-- | Displays a document with the magenta forecolor
magenta :: Doc -> Doc

-- | Displays a document with the dull blue forecolor
dullblue :: Doc -> Doc

-- | Displays a document with the blue forecolor
blue :: Doc -> Doc

-- | Displays a document with the dull yellow forecolor
dullyellow :: Doc -> Doc

-- | Displays a document with the yellow forecolor
yellow :: Doc -> Doc

-- | Displays a document with the dull green forecolor
dullgreen :: Doc -> Doc

-- | Displays a document with the green forecolor
green :: Doc -> Doc

-- | Displays a document with the dull red forecolor
dullred :: Doc -> Doc

-- | Displays a document with the red forecolor
red :: Doc -> Doc

-- | Displays a document with the dull black forecolor
dullblack :: Doc -> Doc

-- | Displays a document with the black forecolor
black :: Doc -> Doc

-- | A document that is normally rendered as the first argument, but when
--   flattened, is rendered as the second document.
flatAlt :: Doc -> Doc -> Doc

-- | The <tt>group</tt> combinator is used to specify alternative layouts.
--   The document <tt>(group x)</tt> undoes all line breaks in document
--   <tt>x</tt>. The resulting line is added to the current line if that
--   fits the page. Otherwise, the document <tt>x</tt> is rendered without
--   any changes.
group :: Doc -> Doc
columns :: (Maybe Int -> Doc) -> Doc
nesting :: (Int -> Doc) -> Doc
column :: (Int -> Doc) -> Doc

-- | The document <tt>(nest i x)</tt> renders document <tt>x</tt> with the
--   current indentation level increased by i (See also <a>hang</a>,
--   <a>align</a> and <a>indent</a>).
--   
--   <pre>
--   nest 2 (text "hello" &lt;$&gt; text "world") &lt;$&gt; text "!"
--   </pre>
--   
--   outputs as:
--   
--   <pre>
--   hello
--     world
--   !
--   </pre>
nest :: Int -> Doc -> Doc

-- | A linebreak that will never be flattened; it is guaranteed to render
--   as a newline.
hardline :: Doc

-- | The <tt>linebreak</tt> document advances to the next line and indents
--   to the current nesting level. Document <tt>linebreak</tt> behaves like
--   <a>empty</a> if the line break is undone by <a>group</a>.
linebreak :: Doc

-- | The <tt>line</tt> document advances to the next line and indents to
--   the current nesting level. Document <tt>line</tt> behaves like
--   <tt>(text " ")</tt> if the line break is undone by <a>group</a>.
line :: Doc

-- | The document <tt>(text s)</tt> contains the literal string <tt>s</tt>.
--   The string shouldn't contain any newline (<tt>'\n'</tt>) characters.
--   If the string contains newline characters, the function <a>string</a>
--   should be used.
text :: String -> Doc

-- | The document <tt>(char c)</tt> contains the literal character
--   <tt>c</tt>. The character shouldn't be a newline (<tt>'\n'</tt>), the
--   function <a>line</a> should be used for line breaks.
char :: Char -> Doc

-- | The empty document is, indeed, empty. Although <tt>empty</tt> has no
--   content, it does have a 'height' of 1 and behaves exactly like
--   <tt>(text "")</tt> (and is therefore not a unit of
--   <tt>&lt;$&gt;</tt>).
empty :: Doc

-- | The document <tt>(align x)</tt> renders document <tt>x</tt> with the
--   nesting level set to the current column. It is used for example to
--   implement <a>hang</a>.
--   
--   As an example, we will put a document right above another one,
--   regardless of the current nesting level:
--   
--   <pre>
--   x $$ y  = align (x &lt;$&gt; y)
--   </pre>
--   
--   <pre>
--   test    = text "hi" &lt;+&gt; (text "nice" $$ text "world")
--   </pre>
--   
--   which will be layed out as:
--   
--   <pre>
--   hi nice
--      world
--   </pre>
align :: Doc -> Doc

-- | The hang combinator implements hanging indentation. The document
--   <tt>(hang i x)</tt> renders document <tt>x</tt> with a nesting level
--   set to the current column plus <tt>i</tt>. The following example uses
--   hanging indentation for some text:
--   
--   <pre>
--   test  = hang 4 (fillSep (map text
--           (words "the hang combinator indents these words !")))
--   </pre>
--   
--   Which lays out on a page with a width of 20 characters as:
--   
--   <pre>
--   the hang combinator
--       indents these
--       words !
--   </pre>
--   
--   The <tt>hang</tt> combinator is implemented as:
--   
--   <pre>
--   hang i x  = align (nest i x)
--   </pre>
hang :: Int -> Doc -> Doc

-- | The document <tt>(indent i x)</tt> indents document <tt>x</tt> with
--   <tt>i</tt> spaces.
--   
--   <pre>
--   test  = indent 4 (fillSep (map text
--           (words "the indent combinator indents these words !")))
--   </pre>
--   
--   Which lays out with a page width of 20 as:
--   
--   <pre>
--   the indent
--   combinator
--   indents these
--   words !
--   </pre>
indent :: Int -> Doc -> Doc
width :: Doc -> (Int -> Doc) -> Doc

-- | The document <tt>(fill i x)</tt> renders document <tt>x</tt>. It than
--   appends <tt>space</tt>s until the width is equal to <tt>i</tt>. If the
--   width of <tt>x</tt> is already larger, nothing is appended. This
--   combinator is quite useful in practice to output a list of bindings.
--   The following example demonstrates this.
--   
--   <pre>
--   types  = [("empty","Doc")
--            ,("nest","Int -&gt; Doc -&gt; Doc")
--            ,("linebreak","Doc")]
--   
--   ptype (name,tp)
--          = fill 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   
--   test   = text "let" &lt;+&gt; align (vcat (map ptype types))
--   </pre>
--   
--   Which is layed out as:
--   
--   <pre>
--   let empty  :: Doc
--       nest   :: Int -&gt; Doc -&gt; Doc
--       linebreak :: Doc
--   </pre>
fill :: Int -> Doc -> Doc

-- | The document <tt>(fillBreak i x)</tt> first renders document
--   <tt>x</tt>. It than appends <tt>space</tt>s until the width is equal
--   to <tt>i</tt>. If the width of <tt>x</tt> is already larger than
--   <tt>i</tt>, the nesting level is increased by <tt>i</tt> and a
--   <tt>line</tt> is appended. When we redefine <tt>ptype</tt> in the
--   previous example to use <tt>fillBreak</tt>, we get a useful variation
--   of the previous output:
--   
--   <pre>
--   ptype (name,tp)
--          = fillBreak 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   </pre>
--   
--   The output will now be:
--   
--   <pre>
--   let empty  :: Doc
--       nest   :: Int -&gt; Doc -&gt; Doc
--       linebreak
--              :: Doc
--   </pre>
fillBreak :: Int -> Doc -> Doc

-- | The document <tt>(rational r)</tt> shows the literal rational
--   <tt>r</tt> using <a>text</a>.
rational :: Rational -> Doc

-- | The document <tt>(double d)</tt> shows the literal double <tt>d</tt>
--   using <a>text</a>.
double :: Double -> Doc

-- | The document <tt>(float f)</tt> shows the literal float <tt>f</tt>
--   using <a>text</a>.
float :: Float -> Doc

-- | The document <tt>(integer i)</tt> shows the literal integer <tt>i</tt>
--   using <a>text</a>.
integer :: Integer -> Doc

-- | The document <tt>(int i)</tt> shows the literal integer <tt>i</tt>
--   using <a>text</a>.
int :: Int -> Doc

-- | The document <tt>(bool b)</tt> shows the literal bool <tt>b</tt> using
--   <a>text</a>.
bool :: Bool -> Doc

-- | The document <tt>(string s)</tt> concatenates all characters in
--   <tt>s</tt> using <tt>line</tt> for newline characters and
--   <tt>char</tt> for all other characters. It is used instead of
--   <a>text</a> whenever the text contains newline characters.
string :: String -> Doc

-- | The document <tt>equals</tt> contains an equal sign, "=".
equals :: Doc

-- | The document <tt>backslash</tt> contains a back slash, "\".
backslash :: Doc

-- | The document <tt>dot</tt> contains a single dot, ".".
dot :: Doc

-- | The document <tt>space</tt> contains a single space, " ".
--   
--   <pre>
--   x &lt;+&gt; y   = x &lt;&gt; space &lt;&gt; y
--   </pre>
space :: Doc

-- | The document <tt>comma</tt> contains a comma, ",".
comma :: Doc

-- | The document <tt>colon</tt> contains a colon, ":".
colon :: Doc

-- | The document <tt>semi</tt> contains a semicolon, ";".
semi :: Doc

-- | The document <tt>dquote</tt> contains a double quote, '"'.
dquote :: Doc

-- | The document <tt>squote</tt> contains a single quote, "'".
squote :: Doc

-- | The document <tt>rbracket</tt> contains a right square bracket, "]".
rbracket :: Doc

-- | The document <tt>lbracket</tt> contains a left square bracket, "[".
lbracket :: Doc

-- | The document <tt>rbrace</tt> contains a right brace, "}".
rbrace :: Doc

-- | The document <tt>lbrace</tt> contains a left brace, "{".
lbrace :: Doc

-- | The document <tt>rangle</tt> contains a right angle, "&gt;".
rangle :: Doc

-- | The document <tt>langle</tt> contains a left angle, "&lt;".
langle :: Doc

-- | The document <tt>rparen</tt> contains a right parenthesis, ")".
rparen :: Doc

-- | The document <tt>lparen</tt> contains a left parenthesis, "(".
lparen :: Doc

-- | The document <tt>(enclose l r x)</tt> encloses document <tt>x</tt>
--   between documents <tt>l</tt> and <tt>r</tt> using <tt>(&lt;&gt;)</tt>.
--   
--   <pre>
--   enclose l r x   = l &lt;&gt; x &lt;&gt; r
--   </pre>
enclose :: Doc -> Doc -> Doc -> Doc

-- | Document <tt>(brackets x)</tt> encloses document <tt>x</tt> in square
--   brackets, "[" and "]".
brackets :: Doc -> Doc

-- | Document <tt>(angles x)</tt> encloses document <tt>x</tt> in angles,
--   "&lt;" and "&gt;".
angles :: Doc -> Doc

-- | Document <tt>(parens x)</tt> encloses document <tt>x</tt> in
--   parenthesis, "(" and ")".
parens :: Doc -> Doc

-- | Document <tt>(braces x)</tt> encloses document <tt>x</tt> in braces,
--   "{" and "}".
braces :: Doc -> Doc

-- | Document <tt>(dquotes x)</tt> encloses document <tt>x</tt> with double
--   quotes '"'.
dquotes :: Doc -> Doc

-- | Document <tt>(squotes x)</tt> encloses document <tt>x</tt> with single
--   quotes "'".
squotes :: Doc -> Doc

-- | The document <tt>softbreak</tt> behaves like <a>empty</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softbreak  = group linebreak
--   </pre>
softbreak :: Doc

-- | The document <tt>softline</tt> behaves like <a>space</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softline = group line
--   </pre>
softline :: Doc

-- | The document <tt>(x &lt;$$&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <tt>linebreak</tt> in between.
--   (infixr 5)
(<$$>) :: Doc -> Doc -> Doc
infixr 5 <$$>

-- | The document <tt>(x &lt;//&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <a>softbreak</a> in between. This
--   effectively puts <tt>x</tt> and <tt>y</tt> either right next to each
--   other or underneath each other. (infixr 5)
(<//>) :: Doc -> Doc -> Doc
infixr 5 <//>

-- | The document <tt>(x &lt;/&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>softline</a> in between. This effectively
--   puts <tt>x</tt> and <tt>y</tt> either next to each other (with a
--   <tt>space</tt> in between) or underneath each other. (infixr 5)
(</>) :: Doc -> Doc -> Doc
infixr 5 </>

-- | The document <tt>(x &lt;+&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <tt>space</tt> in between. (infixr 6)
(<+>) :: Doc -> Doc -> Doc
infixr 6 <+>

-- | The document <tt>(vcat xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>(&lt;$$&gt;)</tt>. If a <a>group</a> undoes the
--   line breaks inserted by <tt>vcat</tt>, all documents are directly
--   concatenated.
vcat :: [Doc] -> Doc

-- | The document <tt>(hcat xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt>.
hcat :: [Doc] -> Doc

-- | The document <tt>(fillCat xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt> as long as its fits the page,
--   than inserts a <tt>linebreak</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillCat xs  = foldr (&lt;//&gt;) empty xs
--   </pre>
fillCat :: [Doc] -> Doc

-- | The document <tt>(cat xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;&gt;)</tt>, if it fits the page, or
--   vertically with <tt>(&lt;$$&gt;)</tt>.
--   
--   <pre>
--   cat xs  = group (vcat xs)
--   </pre>
cat :: [Doc] -> Doc

-- | The document <tt>(vsep xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>(&lt;$&gt;)</tt>. If a <a>group</a> undoes the
--   line breaks inserted by <tt>vsep</tt>, all documents are separated
--   with a space.
--   
--   <pre>
--   someText = map text (words ("text to lay out"))
--   
--   test     = text "some" &lt;+&gt; vsep someText
--   </pre>
--   
--   This is layed out as:
--   
--   <pre>
--   some text
--   to
--   lay
--   out
--   </pre>
--   
--   The <a>align</a> combinator can be used to align the documents under
--   their first element
--   
--   <pre>
--   test     = text "some" &lt;+&gt; align (vsep someText)
--   </pre>
--   
--   Which is printed as:
--   
--   <pre>
--   some text
--        to
--        lay
--        out
--   </pre>
vsep :: [Doc] -> Doc

-- | The document <tt>(hsep xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt>.
hsep :: [Doc] -> Doc

-- | The document <tt>(fillSep xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt> as long as its fits the page,
--   than inserts a <tt>line</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillSep xs  = foldr (&lt;/&gt;) empty xs
--   </pre>
fillSep :: [Doc] -> Doc

-- | The document <tt>(sep xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;+&gt;)</tt>, if it fits the page, or
--   vertically with <tt>(&lt;$&gt;)</tt>.
--   
--   <pre>
--   sep xs  = group (vsep xs)
--   </pre>
sep :: [Doc] -> Doc

-- | <tt>(punctuate p xs)</tt> concatenates all documents in <tt>xs</tt>
--   with document <tt>p</tt> except for the last document.
--   
--   <pre>
--   someText = map text ["words","in","a","tuple"]
--   test     = parens (align (cat (punctuate comma someText)))
--   </pre>
--   
--   This is layed out on a page width of 20 as:
--   
--   <pre>
--   (words,in,a,tuple)
--   </pre>
--   
--   But when the page width is 15, it is layed out as:
--   
--   <pre>
--   (words,
--    in,
--    a,
--    tuple)
--   </pre>
--   
--   (If you want put the commas in front of their elements instead of at
--   the end, you should use <a>tupled</a> or, in general,
--   <a>encloseSep</a>.)
punctuate :: Doc -> [Doc] -> [Doc]

-- | The document <tt>(encloseSep l r sep xs)</tt> concatenates the
--   documents <tt>xs</tt> separated by <tt>sep</tt> and encloses the
--   resulting document by <tt>l</tt> and <tt>r</tt>. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All separators are put in front of the elements.
--   For example, the combinator <a>list</a> can be defined with
--   <tt>encloseSep</tt>:
--   
--   <pre>
--   list xs = encloseSep lbracket rbracket comma xs
--   test    = text "list" &lt;+&gt; (list (map int [10,200,3000]))
--   </pre>
--   
--   Which is layed out with a page width of 20 as:
--   
--   <pre>
--   list [10,200,3000]
--   </pre>
--   
--   But when the page width is 15, it is layed out as:
--   
--   <pre>
--   list [10
--        ,200
--        ,3000]
--   </pre>
encloseSep :: Doc -> Doc -> Doc -> [Doc] -> Doc

-- | The document <tt>(semiBraces xs)</tt> separates the documents
--   <tt>xs</tt> with semicolons and encloses them in braces. The documents
--   are rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All semicolons are put in front of the elements.
semiBraces :: [Doc] -> Doc

-- | The document <tt>(tupled xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in parenthesis. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
tupled :: [Doc] -> Doc

-- | The document <tt>(list xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in square brackets. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
list :: [Doc] -> Doc

-- | The member <tt>prettyList</tt> is only used to define the <tt>instance
--   Pretty a =&gt; Pretty [a]</tt>. In normal circumstances only the
--   <tt>pretty</tt> function is used.
class Pretty a
pretty :: Pretty a => a -> Doc
prettyList :: Pretty a => [a] -> Doc

-- | The abstract data type <tt>Doc</tt> represents pretty documents.
--   
--   More specifically, a value of type <tt>Doc</tt> represents a non-empty
--   set of possible renderings of a document. The rendering functions
--   select one of these possibilities.
--   
--   <tt>Doc</tt> is an instance of the <a>Show</a> class. <tt>(show
--   doc)</tt> pretty prints document <tt>doc</tt> with a page width of 80
--   characters and a ribbon width of 32 characters.
--   
--   <pre>
--   show (text "hello" &lt;$&gt; text "world")
--   </pre>
--   
--   Which would return the string "hello\nworld", i.e.
--   
--   <pre>
--   hello
--   world
--   </pre>
data Doc

-- | The data type <tt>SimpleDoc</tt> represents rendered documents and is
--   used by the display functions.
--   
--   Whereas values of the data type <a>Doc</a> represent non-empty sets of
--   possible renderings of a document, values of the data type
--   <tt>SimpleDoc</tt> represent single renderings of a document.
--   
--   The <tt>Int</tt> in <tt>SText</tt> contains the length of the string.
--   The <tt>Int</tt> in <tt>SLine</tt> contains the indentation for that
--   line. The library provides two default display functions
--   <a>displayS</a> and <a>displayIO</a>. You can provide your own display
--   function by writing a function from a <tt>SimpleDoc</tt> to your own
--   output format.
data SimpleDoc
SFail :: SimpleDoc
SEmpty :: SimpleDoc
SChar :: Char -> SimpleDoc -> SimpleDoc
SText :: !Int -> String -> SimpleDoc -> SimpleDoc
SLine :: !Int -> SimpleDoc -> SimpleDoc
SSGR :: [SGR] -> SimpleDoc -> SimpleDoc
instance GHC.Classes.Eq a => GHC.Classes.Eq (Grin.Pretty.WPP a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Grin.Pretty.PP a)
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty a => GHC.Show.Show (Grin.Pretty.WPP a)
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty a => GHC.Show.Show (Grin.Pretty.PP a)
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty a => Text.PrettyPrint.ANSI.Leijen.Internal.Pretty (Data.Set.Internal.Set a)

module Grin.Interpreter.Store

-- | Store maps addresses to abstract values.
newtype Store a v
Store :: Map a v -> Store a v
empty :: Ord a => Store a v
lookup :: Ord a => a -> Store a v -> v
insert :: Ord a => a -> v -> Store a v -> Store a v
size :: Store a v -> Int
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Grin.Interpreter.Store.Store a v)
instance (GHC.Classes.Ord a, GHC.Classes.Ord v) => GHC.Classes.Ord (Grin.Interpreter.Store.Store a v)
instance (GHC.Classes.Eq a, GHC.Classes.Eq v) => GHC.Classes.Eq (Grin.Interpreter.Store.Store a v)
instance (GHC.Classes.Ord a, GHC.Base.Semigroup v) => GHC.Base.Semigroup (Grin.Interpreter.Store.Store a v)
instance (GHC.Classes.Ord a, GHC.Base.Monoid v) => GHC.Base.Monoid (Grin.Interpreter.Store.Store a v)
instance (Text.PrettyPrint.ANSI.Leijen.Internal.Pretty a, Text.PrettyPrint.ANSI.Leijen.Internal.Pretty v) => Text.PrettyPrint.ANSI.Leijen.Internal.Pretty (Grin.Interpreter.Store.Store a v)

module Grin.Value
data Name
NM :: !Text -> Name
[getName] :: Name -> !Text
mkName :: String -> Name
nMap :: (Text -> Text) -> Name -> Name
nameString :: Name -> String
data TagType
C :: TagType
F :: TagType
P :: Int -> TagType
data Tag
Tag :: TagType -> Name -> Tag
[tagType] :: Tag -> TagType
[tagName] :: Tag -> Name
data SimpleValue
SInt64 :: Int64 -> SimpleValue
SWord64 :: Word64 -> SimpleValue
SFloat :: Float -> SimpleValue
SBool :: Bool -> SimpleValue
SChar :: Char -> SimpleValue

-- | Complete node
data Node
Node :: Tag -> [Name] -> Node
data Value
VNode :: Node -> Value
VPrim :: SimpleValue -> Value
data VarOrValue
Var :: Name -> VarOrValue
Val :: Value -> VarOrValue
instance GHC.Show.Show Grin.Value.VarOrValue
instance GHC.Classes.Ord Grin.Value.VarOrValue
instance GHC.Classes.Eq Grin.Value.VarOrValue
instance Data.Data.Data Grin.Value.VarOrValue
instance GHC.Generics.Generic Grin.Value.VarOrValue
instance GHC.Show.Show Grin.Value.Value
instance GHC.Classes.Ord Grin.Value.Value
instance GHC.Classes.Eq Grin.Value.Value
instance Data.Data.Data Grin.Value.Value
instance GHC.Generics.Generic Grin.Value.Value
instance GHC.Show.Show Grin.Value.Node
instance GHC.Classes.Ord Grin.Value.Node
instance GHC.Classes.Eq Grin.Value.Node
instance Data.Data.Data Grin.Value.Node
instance GHC.Generics.Generic Grin.Value.Node
instance GHC.Show.Show Grin.Value.SimpleValue
instance GHC.Classes.Ord Grin.Value.SimpleValue
instance GHC.Classes.Eq Grin.Value.SimpleValue
instance Data.Data.Data Grin.Value.SimpleValue
instance GHC.Generics.Generic Grin.Value.SimpleValue
instance GHC.Show.Show Grin.Value.Tag
instance GHC.Classes.Ord Grin.Value.Tag
instance GHC.Classes.Eq Grin.Value.Tag
instance Data.Data.Data Grin.Value.Tag
instance GHC.Generics.Generic Grin.Value.Tag
instance GHC.Show.Show Grin.Value.TagType
instance GHC.Classes.Ord Grin.Value.TagType
instance GHC.Classes.Eq Grin.Value.TagType
instance Data.Data.Data Grin.Value.TagType
instance GHC.Generics.Generic Grin.Value.TagType
instance GHC.Classes.Ord Grin.Value.Name
instance GHC.Classes.Eq Grin.Value.Name
instance Data.Data.Data Grin.Value.Name
instance GHC.Generics.Generic Grin.Value.Name
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.Value.VarOrValue
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.Value.Value
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.Value.Node
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.Value.SimpleValue
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.Value.Tag
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.Value.TagType
instance GHC.Show.Show Grin.Value.Name
instance GHC.Base.Semigroup Grin.Value.Name
instance GHC.Base.Monoid Grin.Value.Name
instance Data.String.IsString Grin.Value.Name
instance Text.Printf.PrintfArg Grin.Value.Name
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.Value.Name

module Grin.TypeEnv
type Loc = Int
data SimpleType
T_Int64 :: SimpleType
T_Word64 :: SimpleType
T_Float :: SimpleType
T_Bool :: SimpleType
T_Char :: SimpleType
T_Location :: [Loc] -> SimpleType
[_locations] :: SimpleType -> [Loc]
T_Unit :: SimpleType
type NodeSet = Map Tag [SimpleType]
data Type
T_SimpleType :: SimpleType -> Type
[_simpleType] :: Type -> SimpleType
T_NodeSet :: NodeSet -> Type
[_nodeSet] :: Type -> NodeSet
data TypeEnv
TypeEnv :: Map Int NodeSet -> Map Name Type -> Map Name (Type, [Type]) -> TypeEnv
[_location] :: TypeEnv -> Map Int NodeSet
[_variable] :: TypeEnv -> Map Name Type
[_function] :: TypeEnv -> Map Name (Type, [Type])
data Ty
TyCon :: Name -> [Ty] -> Ty
TyVar :: Name -> Ty
TySimple :: SimpleType -> Ty
emptyTypeEnv :: TypeEnv
variable :: Lens' TypeEnv (Map Name Type)
location :: Lens' TypeEnv (Map Int NodeSet)
function :: Lens' TypeEnv (Map Name (Type, [Type]))
simpleType :: Traversal' Type SimpleType
nodeSet :: Traversal' Type NodeSet
locations :: Traversal' SimpleType [Loc]
prettyNode :: (Tag, [SimpleType]) -> Doc
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.TypeEnv.SimpleType
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.TypeEnv.Type
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.TypeEnv.TypeEnv
instance GHC.Show.Show Grin.TypeEnv.Ty
instance GHC.Classes.Ord Grin.TypeEnv.Ty
instance GHC.Classes.Eq Grin.TypeEnv.Ty
instance GHC.Show.Show Grin.TypeEnv.TypeEnv
instance GHC.Classes.Eq Grin.TypeEnv.TypeEnv
instance GHC.Show.Show Grin.TypeEnv.Type
instance GHC.Classes.Ord Grin.TypeEnv.Type
instance GHC.Classes.Eq Grin.TypeEnv.Type
instance GHC.Show.Show Grin.TypeEnv.SimpleType
instance GHC.Classes.Ord Grin.TypeEnv.SimpleType
instance GHC.Classes.Eq Grin.TypeEnv.SimpleType

module Grin.Interpreter.Env

-- | Environment mapping names to abstract values.
newtype Env v
Env :: Map Name v -> Env v
empty :: Env v
lookup :: Env v -> Name -> v
insert :: Name -> v -> Env v -> Env v
inserts :: [(Name, v)] -> Env v -> Env v
instance GHC.Base.Functor Grin.Interpreter.Env.Env
instance GHC.Classes.Ord v => GHC.Classes.Ord (Grin.Interpreter.Env.Env v)
instance GHC.Show.Show v => GHC.Show.Show (Grin.Interpreter.Env.Env v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Grin.Interpreter.Env.Env v)
instance GHC.Base.Semigroup v => GHC.Base.Semigroup (Grin.Interpreter.Env.Env v)
instance GHC.Base.Semigroup v => GHC.Base.Monoid (Grin.Interpreter.Env.Env v)
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty v => Text.PrettyPrint.ANSI.Leijen.Internal.Pretty (Grin.Interpreter.Env.Env v)

module Grin.Exp

-- | Bind patterns that can be found in the EBind epxressions.
data BPat
BNodePat :: Tag -> [Name] -> BPat
BVar :: Name -> BPat
BUnit :: BPat

-- | Case patterns that can be found in the Alt expressions.
data CPat
NodePat :: Tag -> [Name] -> CPat
LitPat :: SimpleValue -> CPat
DefaultPat :: CPat
data External
External :: Name -> Ty -> [Ty] -> Bool -> External
[eName] :: External -> Name
[eRetType] :: External -> Ty
[eArgsType] :: External -> [Ty]
[eEffectful] :: External -> Bool
data Exp
Program :: [External] -> [Def] -> Exp
Def :: Name -> [Name] -> Exp -> Exp
EBind :: Exp -> BPat -> Exp -> Exp
ECase :: Name -> [Alt] -> Exp
SApp :: Name -> [Name] -> Exp
SPure :: VarOrValue -> Exp
SStore :: Name -> Exp
SFetch :: Name -> Exp
SUpdate :: Name -> Name -> Exp
Alt :: CPat -> Exp -> Exp
Block :: Exp -> Exp
type Program = Exp
type Def = Exp
type Alt = Exp
type SimpleExp = Exp
isExternalName :: [External] -> Name -> Bool
externals :: Exp -> [External]
programToDefs :: Program -> Map Name Exp
data RenderingOption
Simple :: RenderingOption
WithExternals :: RenderingOption
data ExpF r_azs6
ProgramF :: [External] -> [r_azs6] -> ExpF r_azs6
DefF :: Name -> [Name] -> r_azs6 -> ExpF r_azs6
EBindF :: r_azs6 -> BPat -> r_azs6 -> ExpF r_azs6
ECaseF :: Name -> [r_azs6] -> ExpF r_azs6
SAppF :: Name -> [Name] -> ExpF r_azs6
SPureF :: VarOrValue -> ExpF r_azs6
SStoreF :: Name -> ExpF r_azs6
SFetchF :: Name -> ExpF r_azs6
SUpdateF :: Name -> Name -> ExpF r_azs6
AltF :: CPat -> r_azs6 -> ExpF r_azs6
BlockF :: r_azs6 -> ExpF r_azs6
prettyExternals :: [External] -> Doc
prettyProgram :: RenderingOption -> Exp -> Doc

-- | Print a given expression with highlighted external functions.
prettyHighlightExternals :: [External] -> Exp -> Doc
printGrin :: Exp -> IO ()
instance GHC.Read.Read Grin.Exp.RenderingOption
instance GHC.Show.Show Grin.Exp.RenderingOption
instance GHC.Classes.Ord Grin.Exp.RenderingOption
instance GHC.Classes.Eq Grin.Exp.RenderingOption
instance Data.Traversable.Traversable Grin.Exp.ExpF
instance Data.Foldable.Foldable Grin.Exp.ExpF
instance GHC.Base.Functor Grin.Exp.ExpF
instance GHC.Show.Show a => GHC.Show.Show (Grin.Exp.ExpF a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Grin.Exp.ExpF a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Grin.Exp.ExpF a)
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.Exp.Exp
instance Data.Functor.Foldable.Recursive Grin.Exp.Exp
instance Data.Functor.Foldable.Corecursive Grin.Exp.Exp
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.Exp.CPat
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.Exp.BPat
instance Text.PrettyPrint.ANSI.Leijen.Internal.Pretty Grin.TypeEnv.Ty
instance GHC.Show.Show Grin.Exp.Exp
instance GHC.Classes.Ord Grin.Exp.Exp
instance GHC.Classes.Eq Grin.Exp.Exp
instance GHC.Classes.Ord Grin.Exp.BPat
instance GHC.Show.Show Grin.Exp.BPat
instance GHC.Classes.Eq Grin.Exp.BPat
instance GHC.Classes.Ord Grin.Exp.CPat
instance GHC.Show.Show Grin.Exp.CPat
instance GHC.Classes.Eq Grin.Exp.CPat
instance GHC.Show.Show Grin.Exp.External
instance GHC.Classes.Ord Grin.Exp.External
instance GHC.Classes.Eq Grin.Exp.External

module Grin.Interpreter.Base
class (Monad m, MonadFail m) => Interpreter m where {
    type family Val m :: *;
    type family HeapVal m :: *;
    type family Addr m :: *;
}
value :: Interpreter m => Value -> m (Val m)
val2addr :: Interpreter m => Val m -> m (Addr m)
addr2val :: Interpreter m => Addr m -> m (Val m)
heapVal2val :: Interpreter m => HeapVal m -> m (Val m)
val2heapVal :: Interpreter m => Val m -> m (HeapVal m)
unit :: Interpreter m => m (Val m)
bindPattern :: Interpreter m => Val m -> (Tag, [Name]) -> m [(Name, Val m)]

-- | Return the computational environment
askEnv :: Interpreter m => m (Env (Val m))

-- | Set the local environment
localEnv :: Interpreter m => Env (Val m) -> m (Val m) -> m (Val m)
lookupFun :: Interpreter m => Name -> m Exp
isExternal :: Interpreter m => Name -> m Bool
external :: Interpreter m => Name -> [Val m] -> m (Val m)
evalCase :: Interpreter m => (Exp -> m (Val m)) -> Val m -> [Alt] -> m (Val m)
funCall :: Interpreter m => (Exp -> m (Val m)) -> Name -> [Val m] -> m (Val m)
allocStore :: Interpreter m => Name -> m (Val m)
fetchStore :: Interpreter m => Val m -> m (Val m)
extStore :: Interpreter m => Val m -> Val m -> m ()
eval :: (Interpreter m, MonadIO m, Show v, v ~ Val m) => Exp -> m v
baseEval :: (MonadIO m, Interpreter m, a ~ Addr m, v ~ Val m, Show v) => (Exp -> m (Val m)) -> Exp -> m (Val m)

module Grin.Interpreter.Abstract.Base
data Loc
Loc :: Name -> Loc

-- | Simple type for simple values
data ST
ST_Int64 :: ST
ST_Word64 :: ST
ST_Float :: ST
ST_Bool :: ST
ST_Char :: ST
ST_Loc :: Loc -> ST

-- | Node type consist of a Tag and a list with simple types
data Node
Node :: Tag -> [ST] -> Node

-- | The final type could be a Simple-type a Node type or a Unit type
data T
ST :: ST -> T
NT :: Node -> T
UT :: T
typeOfSimpleValue :: SimpleValue -> T

-- | The Abstract environment consist of externals, functions defined in
--   the program and an Environment which can vary.
data AbsEnv
AbsEnv :: Map Name (T, [T]) -> Env T -> Map Name Exp -> AbsEnv
[_absExt] :: AbsEnv -> Map Name (T, [T])
[_absEnv] :: AbsEnv -> Env T
[_absFun] :: AbsEnv -> Map Name Exp
absFun :: Lens' AbsEnv (Map Name Exp)
absExt :: Lens' AbsEnv (Map Name (T, [T]))
absEnv :: Lens' AbsEnv (Env T)

-- | The function type collects the set of possible types.
newtype FunctionT
FunctionT :: (Set T, [Set T]) -> FunctionT

-- | The abstract store associates a set of possible node types with the
--   abstract location.
type AbsStore = Store Loc (Set Node)

-- | The type-env that is computed during the abstract interpretation.
data TypeEnv
TypeEnv :: AbsStore -> Env (Set T) -> Map Name FunctionT -> TypeEnv
[_heap] :: TypeEnv -> AbsStore
[_variable] :: TypeEnv -> Env (Set T)
[_function] :: TypeEnv -> Map Name FunctionT

-- | The abstract state consists only the Abstract Store.
newtype AbsState
AbsState :: AbsStore -> AbsState
[_absStr] :: AbsState -> AbsStore
absStr :: Lens' AbsState AbsStore
newtype AbstractT m a
AbstractT :: RWST AbsEnv () AbsState (LogicT (RWST (TypeEnv, Cache) () (TypeEnv, Cache) m)) a -> AbstractT m a
[abstractT] :: AbstractT m a -> RWST AbsEnv () AbsState (LogicT (RWST (TypeEnv, Cache) () (TypeEnv, Cache) m)) a

-- | How to run the AbstractT monad-stack
runAbstractT :: (Monad m, MonadFail m, MonadIO m) => Program -> [(Name, (T, [T]))] -> AbstractT m a -> m ([(a, AbsState, ())], (TypeEnv, Cache), ())

-- | Simple operator to handle branching.
forMonadPlus :: MonadPlus m => [a] -> (a -> m b) -> m b
data CExp
CApp :: Name -> [Name] -> CExp

-- | The visited configuration
data Config
Config :: CExp -> AbsStore -> Config
[cfgExp] :: Config -> CExp
[cfgStore] :: Config -> AbsStore

-- | The cache associates a function call with a set of the type of the
--   return value and the state of the abstract store.
data Cache
Cache :: Map Config (Set (T, AbsStore)) -> Cache
inCache :: Config -> Cache -> Bool
getCache :: Config -> Cache -> [(T, AbsStore)]
insertCache :: Config -> [(T, AbsStore)] -> Cache -> Cache
instance GHC.Base.MonadPlus (Grin.Interpreter.Abstract.Base.AbstractT m)
instance GHC.Base.Alternative (Grin.Interpreter.Abstract.Base.AbstractT m)
instance Control.Monad.Reader.Class.MonadReader Grin.Interpreter.Abstract.Base.AbsEnv (Grin.Interpreter.Abstract.Base.AbstractT m)
instance Control.Monad.State.Class.MonadState Grin.Interpreter.Abstract.Base.AbsState (Grin.Interpreter.Abstract.Base.AbstractT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Grin.Interpreter.Abstract.Base.AbstractT m)
instance GHC.Base.Monad (Grin.Interpreter.Abstract.Base.AbstractT m)
instance GHC.Base.Applicative (Grin.Interpreter.Abstract.Base.AbstractT m)
instance GHC.Base.Functor (Grin.Interpreter.Abstract.Base.AbstractT m)
instance GHC.Show.Show Grin.Interpreter.Abstract.Base.Cache
instance GHC.Classes.Eq Grin.Interpreter.Abstract.Base.Cache
instance GHC.Classes.Ord Grin.Interpreter.Abstract.Base.Config
instance GHC.Show.Show Grin.Interpreter.Abstract.Base.Config
instance GHC.Classes.Eq Grin.Interpreter.Abstract.Base.Config
instance GHC.Classes.Ord Grin.Interpreter.Abstract.Base.CExp
instance GHC.Show.Show Grin.Interpreter.Abstract.Base.CExp
instance GHC.Classes.Eq Grin.Interpreter.Abstract.Base.CExp
instance Control.Monad.Fail.MonadFail (Grin.Interpreter.Abstract.Base.AbstractT m)
instance GHC.Base.Semigroup Grin.Interpreter.Abstract.Base.Cache
instance GHC.Base.Monoid Grin.Interpreter.Abstract.Base.Cache
instance GHC.Base.Semigroup Grin.Interpreter.Abstract.Base.TypeEnv
instance GHC.Base.Monoid Grin.Interpreter.Abstract.Base.TypeEnv
instance GHC.Base.Semigroup Grin.Interpreter.Abstract.Base.FunctionT
instance GHC.Base.Monoid Grin.Interpreter.Abstract.Base.FunctionT
instance GHC.Classes.Eq Grin.Interpreter.Abstract.Base.AbsState
instance GHC.Show.Show Grin.Interpreter.Abstract.Base.AbsState
instance GHC.Classes.Eq Grin.Interpreter.Abstract.Base.TypeEnv
instance GHC.Classes.Eq Grin.Interpreter.Abstract.Base.FunctionT
instance GHC.Show.Show Grin.Interpreter.Abstract.Base.T
instance GHC.Classes.Ord Grin.Interpreter.Abstract.Base.T
instance GHC.Classes.Eq Grin.Interpreter.Abstract.Base.T
instance GHC.Show.Show Grin.Interpreter.Abstract.Base.Node
instance GHC.Classes.Ord Grin.Interpreter.Abstract.Base.Node
instance GHC.Classes.Eq Grin.Interpreter.Abstract.Base.Node
instance GHC.Show.Show Grin.Interpreter.Abstract.Base.ST
instance GHC.Classes.Ord Grin.Interpreter.Abstract.Base.ST
instance GHC.Classes.Eq Grin.Interpreter.Abstract.Base.ST
instance GHC.Show.Show Grin.Interpreter.Abstract.Base.Loc
instance GHC.Classes.Ord Grin.Interpreter.Abstract.Base.Loc
instance GHC.Classes.Eq Grin.Interpreter.Abstract.Base.Loc

module Grin.Interpreter.Abstract.Interpreter
getCacheOut :: Monad m => AbstractT m Cache
putCacheOut :: Monad m => Cache -> AbstractT m ()
updateCacheOut :: Monad m => (Cache -> Cache) -> AbstractT m ()

-- | Joins the given Env T to the end result
collectEnv :: Monad m => Env T -> AbstractT m ()

-- | Joins the type of the funcion to the end result
collectFunctionType :: Monad m => (Name, [T], T) -> AbstractT m ()
askCacheIn :: Monad m => AbstractT m Cache
localCacheIn :: Monad m => Cache -> AbstractT m a -> AbstractT m a
cache2TypeEnv :: Cache -> TypeEnv
exp2CExp :: Exp -> Maybe CExp
putStore :: Store Loc (Set Node) -> AbstractT m ()
getStore :: AbstractT m (Store Loc (Set Node))
evalCache :: (Monad m, MonadFail m, MonadIO m) => ((Exp -> AbstractT m T) -> Exp -> AbstractT m T) -> (Exp -> AbstractT m T) -> Exp -> AbstractT m T
mlfp :: (MonadIO m, Monad m) => (Cache -> AbstractT m Cache) -> AbstractT m Cache
fixCache :: (MonadFail m, MonadIO m) => (t -> AbstractT m a) -> t -> AbstractT m ()
instance (GHC.Base.Monad m, Control.Monad.IO.Class.MonadIO m, Control.Monad.Fail.MonadFail m) => Grin.Interpreter.Base.Interpreter (Grin.Interpreter.Abstract.Base.AbstractT m)

module Grin.GExp
type family Elem (c :: ExpCtx) (xs :: [ExpCtx]) (cs :: [ExpCtx]) :: Constraint
type IsExp c cs = Elem c cs cs
data Exp (ctx :: ExpCtx)
[Program] :: [External] -> [Exp  'Def_] -> Exp  'Prg
[Def] :: Name -> [Name] -> Exp  'Bind_ -> Exp  'Def_
[App] :: Name -> [Name] -> Exp  'Simple
[Pure] :: VarOrValue -> Exp  'Simple
[Store] :: Name -> Exp  'Simple
[Fetch] :: Name -> Exp  'Simple
[Update] :: Name -> Name -> Exp  'Simple
[Alt] :: CPat -> Exp  'Bind_ -> Exp  'Alt_
[Case] :: Name -> [Exp  'Alt_] -> Exp  'Case_

-- | <pre>
--   Ebind lhs bpat rhs
--   </pre>
--   
--   corresponds to &gt; lhs &gt;&gt;= bpat -&gt; rhs
[Bind] :: (IsExp lhs [ 'Simple,  'Case_], IsExp rhs [ 'Simple,  'Case_,  'Bind_]) => Exp lhs -> BPat -> Exp rhs -> Exp  'Bind_
data ExpCtx
Simple :: ExpCtx
Bind_ :: ExpCtx
Case_ :: ExpCtx
Alt_ :: ExpCtx
Def_ :: ExpCtx
Prg :: ExpCtx

-- | Bind patterns that can be found in the EBind epxressions.
data BPat
BNodePat :: Tag -> [Name] -> BPat
BVar :: Name -> BPat
BUnit :: BPat

-- | Case patterns that can be found in the Alt expressions.
data CPat
NodePat :: Tag -> [Name] -> CPat
LitPat :: SimpleValue -> CPat
DefaultPat :: CPat
data External
External :: Name -> Ty -> [Ty] -> Bool -> External
[eName] :: External -> Name
[eRetType] :: External -> Ty
[eArgsType] :: External -> [Ty]
[eEffectful] :: External -> Bool

module Grin.GExpToExp
gexpToExp :: forall ctx. Exp ctx -> Exp

module Grin.Examples
add :: Exp  'Prg
fact :: Exp  'Prg
sumSimple :: Exp  'Prg

module Grin.Interpreter.Definitional
data SVal
SInt64 :: Int64 -> SVal
SWord64 :: Word64 -> SVal
SFloat :: Float -> SVal
SBool :: Bool -> SVal
SChar :: Char -> SVal
SLoc :: Loc -> SVal
simpleValue :: SimpleValue -> SVal
data Node
Node :: Tag -> [SVal] -> Node
newtype Loc
Loc :: Int -> Loc
data DVal
DNode :: Node -> DVal
DVal :: SVal -> DVal
DUnit :: DVal
data DefEnv m v
DefEnv :: Map Name Exp -> Map Name ([v] -> m v) -> Env v -> DefEnv m v
[_defFuns] :: DefEnv m v -> Map Name Exp
[_defOps] :: DefEnv m v -> Map Name ([v] -> m v)
[_defEnv] :: DefEnv m v -> Env v
defOps :: forall m_aYaJ v_aYaK m_aYtt. Lens (DefEnv m_aYaJ v_aYaK) (DefEnv m_aYtt v_aYaK) (Map Name ([v_aYaK] -> m_aYaJ v_aYaK)) (Map Name ([v_aYaK] -> m_aYtt v_aYaK))
defFuns :: forall m_aYaJ v_aYaK. Lens' (DefEnv m_aYaJ v_aYaK) (Map Name Exp)
defEnv :: forall m_aYaJ v_aYaK. Lens' (DefEnv m_aYaJ v_aYaK) (Env v_aYaK)
newtype DefinitionalT m a
DefinitionalT :: StateT (Store Loc Node) (ReaderT (DefEnv m DVal) m) a -> DefinitionalT m a
[definitionalT] :: DefinitionalT m a -> StateT (Store Loc Node) (ReaderT (DefEnv m DVal) m) a
runDefinitionalT :: Monad m => Exp -> [(Name, [DVal] -> m DVal)] -> DefinitionalT m a -> m a
evalDefinitional :: (Monad m, MonadFail m, MonadIO m) => Program -> m DVal
tests :: IO ()
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState (Grin.Interpreter.Store.Store Grin.Interpreter.Definitional.Loc Grin.Interpreter.Definitional.Node) (Grin.Interpreter.Definitional.DefinitionalT m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader (Grin.Interpreter.Definitional.DefEnv m Grin.Interpreter.Definitional.DVal) (Grin.Interpreter.Definitional.DefinitionalT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Grin.Interpreter.Definitional.DefinitionalT m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Grin.Interpreter.Definitional.DefinitionalT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Grin.Interpreter.Definitional.DefinitionalT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Grin.Interpreter.Definitional.DefinitionalT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Grin.Interpreter.Definitional.DefinitionalT m)
instance (GHC.Base.Applicative m, GHC.Base.Monad m, Control.Monad.Fail.MonadFail m) => Grin.Interpreter.Base.Interpreter (Grin.Interpreter.Definitional.DefinitionalT m)
instance GHC.Show.Show Grin.Interpreter.Definitional.DVal
instance GHC.Classes.Ord Grin.Interpreter.Definitional.DVal
instance GHC.Classes.Eq Grin.Interpreter.Definitional.DVal
instance GHC.Show.Show Grin.Interpreter.Definitional.Node
instance GHC.Classes.Ord Grin.Interpreter.Definitional.Node
instance GHC.Classes.Eq Grin.Interpreter.Definitional.Node
instance GHC.Show.Show Grin.Interpreter.Definitional.SVal
instance GHC.Classes.Ord Grin.Interpreter.Definitional.SVal
instance GHC.Classes.Eq Grin.Interpreter.Definitional.SVal
instance GHC.Show.Show Grin.Interpreter.Definitional.Loc
instance GHC.Classes.Ord Grin.Interpreter.Definitional.Loc
instance GHC.Classes.Eq Grin.Interpreter.Definitional.Loc

module Grin.Interpreter.Abstract.TypeInference
tests :: IO ()
typeInference :: (Monad m, MonadFail m, MonadIO m) => Program -> m TypeEnv
abstractEval :: (Monad m, MonadFail m, MonadIO m) => Program -> m (TypeEnv, Cache)
tToType :: Map Loc Int -> T -> Type
typeOfValue :: SimpleValue -> Type
stToSimpleType :: Map Loc Int -> ST -> SimpleType
locsToLocation :: Store Loc (Set Node) -> (Map Loc Int, Map Int NodeSet)
applyIfBoth :: (Applicative f, Alternative f) => (a -> a -> a) -> f a -> f a -> f a
unifyNodeSet :: NodeSet -> NodeSet -> Maybe NodeSet
unifySimpleType :: SimpleType -> SimpleType -> Maybe SimpleType
unifyType :: Type -> Type -> Maybe Type
funcToFunctions :: Map Loc Int -> Map Name FunctionT -> Map Name (Type, [Type])
varToVariable :: Map Loc Int -> Env (Set T) -> Map Name Type
unifyTypes :: Set Type -> Maybe Type
calcTypeEnv :: TypeEnv -> TypeEnv

module Tutorial.Chapter01.Exercise01
convertGExpToExp :: forall ctx. Exp ctx -> Exp

module Tutorial.Chapter01.Exercise02
data Value
Prim :: SValue -> Value
Node :: Node -> Value
Unit :: Value
data Node
N :: Tag -> [SValue] -> Node
[tag] :: Node -> Tag
[args] :: Node -> [SValue]
data SValue
SInt64 :: Int64 -> SValue
SWord64 :: Word64 -> SValue
SFloat :: Float -> SValue
SBool :: Bool -> SValue
SChar :: Char -> SValue
SLoc :: Address -> SValue

-- | For simplicity's sake, we will represent addresses using Ints.
type Address = Int

-- | How to interpret External names in the interpreter.
type InterpretExternal = Map Name ([Value] -> IO Value)
data Functions
Functions :: Map Name Exp -> InterpretExternal -> Functions

-- | Functions defined within the GRIN program
[functions] :: Functions -> Map Name Exp

-- | Externals used within the GRIN program
[externals] :: Functions -> InterpretExternal
newtype Definitional m a
Definitional :: RWST (Functions, Env Value) () (Store Address Node) m a -> Definitional m a

-- | Collection of the needed constraints.
type DC m = (Monad m, MonadIO m, MonadFail m)
interpreter :: InterpretExternal -> Program -> IO Value

-- | Turns a Simple Value from a syntax to a simple value of the semantics.
simpleValue :: SimpleValue -> SValue

-- | Looks up a name from the active frame/environment and returns its
--   value.
valueOf :: DC m => Name -> Definitional m Value

-- | Looks up a name from the active frame/environment and returns its
--   value, expecting a simple value.
svalueOf :: DC m => Name -> Definitional m SValue

-- | Creates a new location that can be used in the Store operation. The
--   size of the underlying Map will be always the last created location
--   +1, which serves the purpose of a new address.
alloc :: DC m => Definitional m Address
eval :: DC m => Exp -> Definitional m Value

-- | How to turn a source defined value to a runtime value
value :: DC m => Value -> Definitional m Value

-- | Convert a runtime value to an address value
val2addr :: DC m => Value -> Definitional m Address

-- | Convert an address value to a runtime value.
addr2val :: DC m => Address -> Definitional m Value

-- | Convert a heap value, which is a node to a runtime value
heapVal2val :: DC m => Node -> Definitional m Value

-- | Convert a runtime value to a Node value
val2heapVal :: DC m => Value -> Definitional m Node

-- | Creates the Unit value, which is only created when the Update
--   operation runs.
unit :: DC m => Definitional m Value

-- | Creates a list of Name and runtime value pairs which extends the
--   environment for the right hand side of the bind. See in lazyAdd or in
--   sumSimple
bindPattern :: DC m => Value -> (Tag, [Name]) -> Definitional m [(Name, Value)]

-- | Return the environment, which associates names with values
askEnv :: DC m => Definitional m (Env Value)

-- | Sets the environment to the given one, this is for binds, function
--   calls, and alternatives.
localEnv :: DC m => Env Value -> Definitional m Value -> Definitional m Value

-- | Lookup a function by its name. It should return the Def constructor
--   which contains the parameters and the body of the function.
lookupFun :: DC m => Name -> Definitional m Exp

-- | Checks if the given name refers to an external function.
isExternal :: DC m => Name -> Definitional m Bool

-- | Run the given external with the parameters
external :: DC m => Name -> [Value] -> Definitional m Value
funCall :: DC m => (Exp -> Definitional m Value) -> Name -> [Value] -> Definitional m Value
evalCase :: DC m => (Exp -> Definitional m Value) -> Value -> [Alt] -> Definitional m Value

-- | Creates a location for a given name. This is particular for the GRIN
--   store structure, where the Store operation must be part of a Bind,
--   thus there will be always a name to bind to, which should hold the
--   address of the created location.
--   
--   In this Definitional interpreter for every Store operation that the
--   interpreter evaluates it must creates a new location.
allocStore :: DC m => Name -> Definitional m Value

-- | Loads the content from the store addressed by the given value
fetchStore :: DC m => Value -> Definitional m Value

-- | Extends the store with the given value.
extStore :: DC m => Value -> Value -> Definitional m ()
knownExternals :: Map Name ([Value] -> IO Value)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Tutorial.Chapter01.Exercise02.Definitional m)
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState (Grin.Interpreter.Store.Store Tutorial.Chapter01.Exercise02.Address Tutorial.Chapter01.Exercise02.Node) (Tutorial.Chapter01.Exercise02.Definitional m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader (Tutorial.Chapter01.Exercise02.Functions, Grin.Interpreter.Env.Env Tutorial.Chapter01.Exercise02.Value) (Tutorial.Chapter01.Exercise02.Definitional m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Tutorial.Chapter01.Exercise02.Definitional m)
instance GHC.Base.Monad m => GHC.Base.Monad (Tutorial.Chapter01.Exercise02.Definitional m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Tutorial.Chapter01.Exercise02.Definitional m)
instance GHC.Base.Functor m => GHC.Base.Functor (Tutorial.Chapter01.Exercise02.Definitional m)
instance GHC.Show.Show Tutorial.Chapter01.Exercise02.Value
instance GHC.Classes.Eq Tutorial.Chapter01.Exercise02.Value
instance GHC.Show.Show Tutorial.Chapter01.Exercise02.Node
instance GHC.Classes.Eq Tutorial.Chapter01.Exercise02.Node
instance GHC.Show.Show Tutorial.Chapter01.Exercise02.SValue
instance GHC.Classes.Ord Tutorial.Chapter01.Exercise02.SValue
instance GHC.Classes.Eq Tutorial.Chapter01.Exercise02.SValue

module Grin.CheatSheet
type Name = Name
type Tag = Tag
type SimpleValue = SimpleValue
type Node = Node
type Value = Value
type VarOrValue = VarOrValue
type External = External
type CPat = CPat
type BPat = BPat
type ExpCtx = ExpCtx
type GExp = Exp
type Exp = Exp
type Env = Env
type Store = Store
type C01E02_Value = Value
type C01E02_Node = Node
type C01E02_SValue = SValue
type C01E02_Address = Address
type C01E02_InterpretExternal = InterpretExternal
type C01E02_Functions = Functions
type C01E02_Definitional = Definitional
type AbstractT = AbstractT
type Cache = Cache
type TypeEnv = TypeEnv
type T = T
type ST = ST
type Loc = Loc
type AbsStore = AbsStore
type AbsEnv = AbsEnv
type AbsState = AbsState
type C02E02_Node = Node

module Tutorial.Chapter02.Exercise01

-- | The interpreter is written in an open recursive style; the evaluator
--   does not call itself recursively, instead it takes as an argument a
--   function ev (the argument) is called instead of self-recursion. This
--   is a standard encoding for recursive functions in a setting without
--   recursive binding. It is up to an external function, such as the
--   Y-combinator, to close the recursive loop. This open recursive form is
--   crucial because it allows intercepting recursive calls to perform
--   deep instrumentation of the interpreter.
eval :: (MonadIO m, Interpreter m) => (Exp -> m (Val m)) -> Exp -> m (Val m)
class (Monad m, MonadFail m) => Interpreter m where {
    type family Val m :: *;
    type family HeapVal m :: *;
    type family Addr m :: *;
}
value :: Interpreter m => Value -> m (Val m)
val2addr :: Interpreter m => Val m -> m (Addr m)
addr2val :: Interpreter m => Addr m -> m (Val m)
heapVal2val :: Interpreter m => HeapVal m -> m (Val m)
val2heapVal :: Interpreter m => Val m -> m (HeapVal m)
unit :: Interpreter m => m (Val m)
bindPattern :: Interpreter m => Val m -> (Tag, [Name]) -> m [(Name, Val m)]

-- | Return the computational environment
askEnv :: Interpreter m => m (Env (Val m))

-- | Set the local environment
localEnv :: Interpreter m => Env (Val m) -> m (Val m) -> m (Val m)
lookupFun :: Interpreter m => Name -> m Exp
isExternal :: Interpreter m => Name -> m Bool
external :: Interpreter m => Name -> [Val m] -> m (Val m)
evalCase :: Interpreter m => (Exp -> m (Val m)) -> Val m -> [Alt] -> m (Val m)
funCall :: Interpreter m => (Exp -> m (Val m)) -> Name -> [Val m] -> m (Val m)
allocStore :: Interpreter m => Name -> m (Val m)
fetchStore :: Interpreter m => Val m -> m (Val m)
extStore :: Interpreter m => Val m -> Val m -> m ()
instance (Control.Monad.IO.Class.MonadIO m, GHC.Base.Monad m, Control.Monad.Fail.MonadFail m) => Tutorial.Chapter02.Exercise01.Interpreter (Tutorial.Chapter01.Exercise02.Definitional m)

module Tutorial.Chapter02.Exercise02
typeInference :: (Monad m, MonadFail m, MonadIO m) => Program -> m TypeEnv
evalAbstract :: (Monad m, MonadFail m, MonadIO m) => Program -> m (TypeEnv, Cache)
instance (GHC.Base.Monad m, Control.Monad.IO.Class.MonadIO m, Control.Monad.Fail.MonadFail m) => Tutorial.Chapter02.Exercise01.Interpreter (Grin.Interpreter.Abstract.Base.AbstractT m)

module Tutorial.Chapter03.Exercise01
renameVars :: Name -> Name -> Int -> Exp -> Exp
inlineEval :: Exp -> Exp
bindNormalisation :: Exp -> Exp

module Tutorial.Chapter03.Exercise02

-- | Sparse case optimisation uses ana to transform the program from top to
--   down. It checks if the given alterntive can be removed. The
--   alternative can be removed if it does not match any of the Nodes in
--   the type associated with the variable. Literal matching alternatives
--   must be kept.
sparseCaseOptimisation :: TypeEnv -> Exp -> Exp

-- | Returns True if the given pattern can be matched with the type of the
--   scrutinee
matchingAlt :: Type -> CPat -> Bool

-- | Remove the redundant detault
removeTheRedundantDefault :: Type -> [Alt] -> [Alt]
